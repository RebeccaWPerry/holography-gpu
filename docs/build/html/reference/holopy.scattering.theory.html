

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>theory Package &mdash; HoloPy 2.0.0 documentation</title>
    
    <link rel="stylesheet" href="../_static/default.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '2.0.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="top" title="HoloPy 2.0.0 documentation" href="../index.html" />
    <link rel="up" title="scattering Package" href="holopy.scattering.html" />
    <link rel="next" title="fitting Package" href="holopy.fitting.html" />
    <link rel="prev" title="scatterer Package" href="holopy.scattering.scatterer.html" /> 
  </head>
  <body>

<div style="background-color: white; text-align: left; padding: 10px 10px 15px 15px">
<a href="../index.html"><img src="../_static/logo.png" border="0" alt="HoloPy"/></a> HoloPy
</div>

    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="holopy.fitting.html" title="fitting Package"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="holopy.scattering.scatterer.html" title="scatterer Package"
             accesskey="P">previous</a> |</li>
        <li><a href="../index.html">home</a>|&nbsp;</li>
        <li><a href="../search.html">search</a>|&nbsp;</li>

          <li><a href="holopy.html" ><tt class="docutils literal"><span class="pre">holopy</span></tt> Code Reference</a> &raquo;</li>
          <li><a href="holopy.scattering.html" accesskey="U">scattering Package</a> &raquo;</li> 
      </ul>
    </div>

      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">theory Package</a><ul>
<li><a class="reference internal" href="#id1"><tt class="docutils literal"><span class="pre">theory</span></tt> Package</a></li>
<li><a class="reference internal" href="#module-holopy.scattering.theory.mie"><tt class="docutils literal"><span class="pre">mie</span></tt> Module</a></li>
<li><a class="reference internal" href="#module-holopy.scattering.theory.multisphere"><tt class="docutils literal"><span class="pre">multisphere</span></tt> Module</a></li>
<li><a class="reference internal" href="#module-holopy.scattering.theory.dda"><tt class="docutils literal"><span class="pre">dda</span></tt> Module</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="holopy.scattering.scatterer.html"
                        title="previous chapter">scatterer Package</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="holopy.fitting.html"
                        title="next chapter">fitting Package</a></p>
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="../_sources/reference/holopy.scattering.theory.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="theory-package">
<h1>theory Package<a class="headerlink" href="#theory-package" title="Permalink to this headline">¶</a></h1>
<div class="section" id="id1">
<h2><tt class="xref py py-mod docutils literal"><span class="pre">theory</span></tt> Package<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h2>
<span class="target" id="module-holopy.scattering.theory"></span><p>Theories to compute scattering from objects.</p>
<p>All theories have a common interface defined by
<a class="reference internal" href="#holopy.scattering.theory.scatteringtheory.ScatteringTheory" title="holopy.scattering.theory.scatteringtheory.ScatteringTheory"><tt class="xref py py-class docutils literal"><span class="pre">holopy.scattering.theory.scatteringtheory.ScatteringTheory</span></tt></a>.</p>
<dl class="class">
<dt id="holopy.scattering.theory.scatteringtheory.ScatteringTheory">
<em class="property">class </em><tt class="descclassname">holopy.scattering.theory.scatteringtheory.</tt><tt class="descname">ScatteringTheory</tt><a class="headerlink" href="#holopy.scattering.theory.scatteringtheory.ScatteringTheory" title="Permalink to this definition">¶</a></dt>
<dd><p>Defines common interface for all scattering theories.</p>
<p class="rubric">Notes</p>
<p>A subclasses that do the work of computing scattering should do it by
implementing a _calc_field(self, scatterer, schema) function that returns a
VectorGrid electric field.</p>
<p>ScatteringTheory uses pseudo classmethods which when called on a
ScatteringTheory class are in fact called on a default instantiation
(no parameters given to the constructor).  If you manually instantiate a
ScatteringTheory Object then it&#8217;s calc_* methods refer to itself.</p>
<dl class="classmethod">
<dt id="holopy.scattering.theory.scatteringtheory.ScatteringTheory.calc_cross_sections">
<em class="property">classmethod </em><tt class="descname">calc_cross_sections</tt><big>(</big><em>cls_self</em>, <em>scatterer</em>, <em>optics</em><big>)</big><a class="headerlink" href="#holopy.scattering.theory.scatteringtheory.ScatteringTheory.calc_cross_sections" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate scattering, absorption, and extinction
cross sections, and asymmetry parameter &lt;cos    heta&gt;.
To be implemented by derived classes.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>scatterer</strong> : <a class="reference internal" href="holopy.scattering.scatterer.html#module-holopy.scattering.scatterer" title="holopy.scattering.scatterer"><tt class="xref py py-mod docutils literal"><span class="pre">scatterer</span></tt></a> object</p>
<blockquote>
<div><p>(possibly composite) scatterer for which to compute scattering</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns :</th><td class="field-body"><p class="first"><strong>cross_sections</strong> : array (4)</p>
<blockquote class="last">
<div><p>Dimensional scattering, absorption, and extinction
cross sections, and &lt;cos theta&gt;</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>calc_* functions can be called on either a theory class or a theory
object.  If called on a theory class, they use a default theory object
which is correct for the vast majority of situations.  You only need to
instantiate a theory object if it has adjustable parameters and you want
to use non-default values.</p>
</dd></dl>

<dl class="classmethod">
<dt id="holopy.scattering.theory.scatteringtheory.ScatteringTheory.calc_field">
<em class="property">classmethod </em><tt class="descname">calc_field</tt><big>(</big><em>cls_self</em>, <em>scatterer</em>, <em>schema</em>, <em>scaling=1.0</em><big>)</big><a class="headerlink" href="#holopy.scattering.theory.scatteringtheory.ScatteringTheory.calc_field" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate fields.  Implemented in derived classes only.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>scatterer</strong> : <a class="reference internal" href="holopy.scattering.scatterer.html#module-holopy.scattering.scatterer" title="holopy.scattering.scatterer"><tt class="xref py py-mod docutils literal"><span class="pre">scatterer</span></tt></a> object</p>
<blockquote>
<div><p>(possibly composite) scatterer for which to compute scattering</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns :</th><td class="field-body"><p class="first"><strong>e_field</strong> : <tt class="xref py py-mod docutils literal"><span class="pre">VectorGrid</span></tt></p>
<blockquote class="last">
<div><p>scattered electric field</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>calc_* functions can be called on either a theory class or a theory
object.  If called on a theory class, they use a default theory object
which is correct for the vast majority of situations.  You only need to
instantiate a theory object if it has adjustable parameters and you want
to use non-default values.</p>
</dd></dl>

<dl class="classmethod">
<dt id="holopy.scattering.theory.scatteringtheory.ScatteringTheory.calc_holo">
<em class="property">classmethod </em><tt class="descname">calc_holo</tt><big>(</big><em>cls_self</em>, <em>scatterer</em>, <em>schema</em>, <em>scaling=1.0</em><big>)</big><a class="headerlink" href="#holopy.scattering.theory.scatteringtheory.ScatteringTheory.calc_holo" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate hologram formed by interference between scattered
fields and a reference wave</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>scatterer</strong> : <a class="reference internal" href="holopy.scattering.scatterer.html#module-holopy.scattering.scatterer" title="holopy.scattering.scatterer"><tt class="xref py py-mod docutils literal"><span class="pre">scatterer</span></tt></a> object</p>
<blockquote>
<div><p>(possibly composite) scatterer for which to compute scattering</p>
</div></blockquote>
<p><strong>scaling</strong> : scaling value (alpha) for intensity of reference wave</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns :</th><td class="field-body"><p class="first"><strong>holo</strong> : <a class="reference internal" href="holopy.core.marray.html#holopy.core.marray.Image" title="holopy.core.marray.Image"><tt class="xref py py-class docutils literal"><span class="pre">Image</span></tt></a> object</p>
<blockquote class="last">
<div><p>Calculated hologram from the given distribution of spheres</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>calc_* functions can be called on either a theory class or a theory
object.  If called on a theory class, they use a default theory object
which is correct for the vast majority of situations.  You only need to
instantiate a theory object if it has adjustable parameters and you want
to use non-default values.</p>
</dd></dl>

<dl class="classmethod">
<dt id="holopy.scattering.theory.scatteringtheory.ScatteringTheory.calc_intensity">
<em class="property">classmethod </em><tt class="descname">calc_intensity</tt><big>(</big><em>cls_self</em>, <em>scatterer</em>, <em>schema</em>, <em>scaling=1.0</em><big>)</big><a class="headerlink" href="#holopy.scattering.theory.scatteringtheory.ScatteringTheory.calc_intensity" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate intensity at focal plane (z=0)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>scatterer</strong> : <a class="reference internal" href="holopy.scattering.scatterer.html#module-holopy.scattering.scatterer" title="holopy.scattering.scatterer"><tt class="xref py py-mod docutils literal"><span class="pre">scatterer</span></tt></a> object</p>
<blockquote>
<div><p>(possibly composite) scatterer for which to compute scattering</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns :</th><td class="field-body"><p class="first"><strong>inten</strong> : <tt class="xref py py-mod docutils literal"><span class="pre">Image</span></tt></p>
<blockquote class="last">
<div><p>scattered intensity</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>calc_* functions can be called on either a theory class or a theory
object.  If called on a theory class, they use a default theory object
which is correct for the vast majority of situations.  You only need to
instantiate a theory object if it has adjustable parameters and you want
to use non-default values.</p>
<p>Total scattered intensity only takes into account the x- and
y-components of the E-field.  The z-component is ignored
because the detector&#8217;s pixels should be sensitive to the z
component of the Poynting vector, E x B, and the z component
of E x B cannot depend on Ez.</p>
</dd></dl>

<dl class="classmethod">
<dt id="holopy.scattering.theory.scatteringtheory.ScatteringTheory.calc_scat_matrix">
<em class="property">classmethod </em><tt class="descname">calc_scat_matrix</tt><big>(</big><em>cls_self</em>, <em>scatterer</em>, <em>schema</em><big>)</big><a class="headerlink" href="#holopy.scattering.theory.scatteringtheory.ScatteringTheory.calc_scat_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute scattering matricies for scatterer</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>scatterer</strong> : <a class="reference internal" href="holopy.scattering.scatterer.html#module-holopy.scattering.scatterer" title="holopy.scattering.scatterer"><tt class="xref py py-mod docutils literal"><span class="pre">holopy.scattering.scatterer</span></tt></a> object</p>
<blockquote>
<div><p>(possibly composite) scatterer for which to compute scattering</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns :</th><td class="field-body"><p class="first"><strong>scat_matr</strong> : <tt class="xref py py-mod docutils literal"><span class="pre">Marray</span></tt></p>
<blockquote class="last">
<div><p>Scattering matricies at specified positions</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>calc_* functions can be called on either a theory class or a theory
object.  If called on a theory class, they use a default theory object
which is correct for the vast majority of situations.  You only need to
instantiate a theory object if it has adjustable parameters and you want
to use non-default values.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-holopy.scattering.theory.mie">
<span id="mie-module"></span><h2><tt class="xref py py-mod docutils literal"><span class="pre">mie</span></tt> Module<a class="headerlink" href="#module-holopy.scattering.theory.mie" title="Permalink to this headline">¶</a></h2>
<p>Calculates holograms of spheres using Fortran implementation of Mie
theory. Uses superposition to calculate scattering from multiple
spheres. Uses full radial dependence of spherical Hankel functions for
scattered field.</p>
<dl class="class">
<dt id="holopy.scattering.theory.mie.Mie">
<em class="property">class </em><tt class="descclassname">holopy.scattering.theory.mie.</tt><tt class="descname">Mie</tt><big>(</big><em>compute_escat_radial=True</em><big>)</big><a class="headerlink" href="#holopy.scattering.theory.mie.Mie" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">holopy.scattering.theory.scatteringtheory.FortranTheory</span></tt></p>
<p>Compute scattering using the Lorenz-Mie solution.</p>
<p>This theory calculates exact scattering for single spheres and approximate
results for groups of spheres.  It does not account for multiple scattering,
hence the approximation in the case of multiple spheres.  Neglecting
multiple scattering is a good approximation if the particles are
sufficiently separated.</p>
<p>This model can also calculate the exact scattered field from a
spherically symmetric particle with an arbitrary number of layers
with differing refractive indices, using Yang&#8217;s recursive
algorithm (<a class="reference internal" href="../credits.html#yang2003">[Yang2003]</a>).</p>
<p>By default, calculates radial component of scattered electric fields,
which is nonradiative.</p>
<dl class="classmethod">
<dt id="holopy.scattering.theory.mie.Mie.calc_cross_sections">
<em class="property">classmethod </em><tt class="descname">calc_cross_sections</tt><big>(</big><em>cls_self</em>, <em>scatterer</em>, <em>optics</em><big>)</big><a class="headerlink" href="#holopy.scattering.theory.mie.Mie.calc_cross_sections" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate scattering, absorption, and extinction
cross sections, and asymmetry parameter &lt;cos    heta&gt;.
To be implemented by derived classes.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>scatterer</strong> : <a class="reference internal" href="holopy.scattering.scatterer.html#module-holopy.scattering.scatterer" title="holopy.scattering.scatterer"><tt class="xref py py-mod docutils literal"><span class="pre">scatterer</span></tt></a> object</p>
<blockquote>
<div><p>(possibly composite) scatterer for which to compute scattering</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns :</th><td class="field-body"><p class="first"><strong>cross_sections</strong> : array (4)</p>
<blockquote class="last">
<div><p>Dimensional scattering, absorption, and extinction
cross sections, and &lt;cos theta&gt;</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>calc_* functions can be called on either a theory class or a theory
object.  If called on a theory class, they use a default theory object
which is correct for the vast majority of situations.  You only need to
instantiate a theory object if it has adjustable parameters and you want
to use non-default values.</p>
</dd></dl>

<dl class="classmethod">
<dt id="holopy.scattering.theory.mie.Mie.calc_field">
<em class="property">classmethod </em><tt class="descname">calc_field</tt><big>(</big><em>cls_self</em>, <em>scatterer</em>, <em>schema</em>, <em>scaling=1.0</em><big>)</big><a class="headerlink" href="#holopy.scattering.theory.mie.Mie.calc_field" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate fields.  Implemented in derived classes only.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>scatterer</strong> : <a class="reference internal" href="holopy.scattering.scatterer.html#module-holopy.scattering.scatterer" title="holopy.scattering.scatterer"><tt class="xref py py-mod docutils literal"><span class="pre">scatterer</span></tt></a> object</p>
<blockquote>
<div><p>(possibly composite) scatterer for which to compute scattering</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns :</th><td class="field-body"><p class="first"><strong>e_field</strong> : <tt class="xref py py-mod docutils literal"><span class="pre">VectorGrid</span></tt></p>
<blockquote class="last">
<div><p>scattered electric field</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>calc_* functions can be called on either a theory class or a theory
object.  If called on a theory class, they use a default theory object
which is correct for the vast majority of situations.  You only need to
instantiate a theory object if it has adjustable parameters and you want
to use non-default values.</p>
</dd></dl>

<dl class="classmethod">
<dt id="holopy.scattering.theory.mie.Mie.calc_holo">
<em class="property">classmethod </em><tt class="descname">calc_holo</tt><big>(</big><em>cls_self</em>, <em>scatterer</em>, <em>schema</em>, <em>scaling=1.0</em><big>)</big><a class="headerlink" href="#holopy.scattering.theory.mie.Mie.calc_holo" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate hologram formed by interference between scattered
fields and a reference wave</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>scatterer</strong> : <a class="reference internal" href="holopy.scattering.scatterer.html#module-holopy.scattering.scatterer" title="holopy.scattering.scatterer"><tt class="xref py py-mod docutils literal"><span class="pre">scatterer</span></tt></a> object</p>
<blockquote>
<div><p>(possibly composite) scatterer for which to compute scattering</p>
</div></blockquote>
<p><strong>scaling</strong> : scaling value (alpha) for intensity of reference wave</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns :</th><td class="field-body"><p class="first"><strong>holo</strong> : <a class="reference internal" href="holopy.core.marray.html#holopy.core.marray.Image" title="holopy.core.marray.Image"><tt class="xref py py-class docutils literal"><span class="pre">Image</span></tt></a> object</p>
<blockquote class="last">
<div><p>Calculated hologram from the given distribution of spheres</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>calc_* functions can be called on either a theory class or a theory
object.  If called on a theory class, they use a default theory object
which is correct for the vast majority of situations.  You only need to
instantiate a theory object if it has adjustable parameters and you want
to use non-default values.</p>
</dd></dl>

<dl class="classmethod">
<dt id="holopy.scattering.theory.mie.Mie.calc_intensity">
<em class="property">classmethod </em><tt class="descname">calc_intensity</tt><big>(</big><em>cls_self</em>, <em>scatterer</em>, <em>schema</em>, <em>scaling=1.0</em><big>)</big><a class="headerlink" href="#holopy.scattering.theory.mie.Mie.calc_intensity" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate intensity at focal plane (z=0)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>scatterer</strong> : <a class="reference internal" href="holopy.scattering.scatterer.html#module-holopy.scattering.scatterer" title="holopy.scattering.scatterer"><tt class="xref py py-mod docutils literal"><span class="pre">scatterer</span></tt></a> object</p>
<blockquote>
<div><p>(possibly composite) scatterer for which to compute scattering</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns :</th><td class="field-body"><p class="first"><strong>inten</strong> : <tt class="xref py py-mod docutils literal"><span class="pre">Image</span></tt></p>
<blockquote class="last">
<div><p>scattered intensity</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>calc_* functions can be called on either a theory class or a theory
object.  If called on a theory class, they use a default theory object
which is correct for the vast majority of situations.  You only need to
instantiate a theory object if it has adjustable parameters and you want
to use non-default values.</p>
<p>Total scattered intensity only takes into account the x- and
y-components of the E-field.  The z-component is ignored
because the detector&#8217;s pixels should be sensitive to the z
component of the Poynting vector, E x B, and the z component
of E x B cannot depend on Ez.</p>
</dd></dl>

<dl class="classmethod">
<dt id="holopy.scattering.theory.mie.Mie.calc_scat_matrix">
<em class="property">classmethod </em><tt class="descname">calc_scat_matrix</tt><big>(</big><em>cls_self</em>, <em>scatterer</em>, <em>schema</em><big>)</big><a class="headerlink" href="#holopy.scattering.theory.mie.Mie.calc_scat_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute scattering matricies for scatterer</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>scatterer</strong> : <a class="reference internal" href="holopy.scattering.scatterer.html#module-holopy.scattering.scatterer" title="holopy.scattering.scatterer"><tt class="xref py py-mod docutils literal"><span class="pre">holopy.scattering.scatterer</span></tt></a> object</p>
<blockquote>
<div><p>(possibly composite) scatterer for which to compute scattering</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns :</th><td class="field-body"><p class="first"><strong>scat_matr</strong> : <tt class="xref py py-mod docutils literal"><span class="pre">Marray</span></tt></p>
<blockquote class="last">
<div><p>Scattering matricies at specified positions</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>calc_* functions can be called on either a theory class or a theory
object.  If called on a theory class, they use a default theory object
which is correct for the vast majority of situations.  You only need to
instantiate a theory object if it has adjustable parameters and you want
to use non-default values.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-holopy.scattering.theory.multisphere">
<span id="multisphere-module"></span><h2><tt class="xref py py-mod docutils literal"><span class="pre">multisphere</span></tt> Module<a class="headerlink" href="#module-holopy.scattering.theory.multisphere" title="Permalink to this headline">¶</a></h2>
<p>Defines Multisphere theory class, which calculates scattering for multiple
spheres using the (exact) superposition method implemented in
modified version of Daniel Mackowski&#8217;s SCSMFO1B.FOR.  Uses full radial
dependence of spherical Hankel functions for the scattered field.</p>
<dl class="class">
<dt id="holopy.scattering.theory.multisphere.Multisphere">
<em class="property">class </em><tt class="descclassname">holopy.scattering.theory.multisphere.</tt><tt class="descname">Multisphere</tt><big>(</big><em>niter=200</em>, <em>eps=1e-06</em>, <em>meth=1</em>, <em>qeps1=1e-05</em>, <em>qeps2=1e-08</em>, <em>compute_escat_radial=False</em><big>)</big><a class="headerlink" href="#holopy.scattering.theory.multisphere.Multisphere" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">holopy.scattering.theory.scatteringtheory.FortranTheory</span></tt></p>
<p>Exact scattering from a cluster of spheres.</p>
<p>Calculate the scattered field of a collection of spheres through a
numerical method that accounts for multiple scattering and near-field
effects (see <a class="reference internal" href="../credits.html#fung2011">[Fung2011]</a>, <a class="reference internal" href="../credits.html#mackowski1996">[Mackowski1996]</a>).  This approach is much more
accurate than Mie superposition, but it is also more computationally
intensive.  The Multisphere code can handle any number of spheres;
see notes below for details.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Attributes :</th><td class="field-body"><p class="first"><strong>niter</strong> : integer (optional)</p>
<blockquote>
<div><p>maximum number of iterations to use in solving the interaction
equations</p>
</div></blockquote>
<p><strong>meth</strong> : integer (optional)</p>
<blockquote>
<div><p>method to use to solve interaction equations.  Set to 0 for
biconjugate gradient; 1 for order-of-scattering</p>
</div></blockquote>
<p><strong>eps</strong> : float (optional)</p>
<blockquote>
<div><p>relative error tolerance in solution for interaction equations</p>
</div></blockquote>
<p><strong>qeps1</strong> : float (optional)</p>
<blockquote>
<div><p>error tolerance used to determine at what order the
single-sphere spherical harmonic expansion should be truncated</p>
</div></blockquote>
<p><strong>qeps2</strong> : float (optional)</p>
<blockquote class="last">
<div><p>error tolerance used to determine at what order the cluster
spherical harmonic expansion should be truncated</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>According to Mackowski&#8217;s manual for SCSMFO1B.FOR <a class="footnote-reference" href="#id7" id="id5">[1]</a> and later
papers <a class="footnote-reference" href="#id8" id="id6">[2]</a>, the biconjugate gradient is generally the most
efficient method for solving the interaction equations, especially
for dense arrays of identical spheres.  Order-of-scattering may
converge better for non-identical spheres.</p>
<p>Multisphere does not check for overlaps becaue overlapping spheres can be
useful for getting fits to converge.  The results to be sensible for small
overlaps even though mathemtically speaking they are not xstrictly valid.</p>
<p>Currently, Multisphere does not calculate the radial component of
scattered electric fields. This is a good approximation for large kr,
since the radial component falls off as 1/kr^2.</p>
<dl class="docutils">
<dt>scfodim.for contains three parameters, all integers:</dt>
<dd><ul class="first last">
<li><p class="first">nod: Maximum number of spheres</p>
</li>
<li><dl class="first docutils">
<dt>nod: Maximum order of individual sphere expansions. Will depend on</dt>
<dd><p class="first last">size of largest sphere in cluster.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>notd: Maximum order of cluster-centered expansion. Will depend on</dt>
<dd><p class="first last">overall size of cluster.</p>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
<p>Changing these values will require recompiling Fortran extensions.</p>
<p class="rubric">References</p>
<table class="docutils footnote" frame="void" id="id7" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id5">[1]</a></td><td>Daniel W. Mackowski, SCSMFO.FOR: Calculation of the Scattering
Properties for a Cluster of Spheres,
<a class="reference external" href="ftp://ftp.eng.auburn.edu/pub/dmckwski/scatcodes/scsmfo.ps">ftp://ftp.eng.auburn.edu/pub/dmckwski/scatcodes/scsmfo.ps</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id8" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id6">[2]</a></td><td>D.W. Mackowski, M.I. Mishchenko, A multiple sphere T-matrix
Fortran code for use on parallel computer clusters, Journal of
Quantitative Spectroscopy and Radiative Transfer, In Press,
Corrected Proof, Available online 11 March 2011, ISSN 0022-4073,
DOI: 10.1016/j.jqsrt.2011.02.019.</td></tr>
</tbody>
</table>
<dl class="classmethod">
<dt id="holopy.scattering.theory.multisphere.Multisphere.calc_cross_sections">
<em class="property">classmethod </em><tt class="descname">calc_cross_sections</tt><big>(</big><em>cls_self</em>, <em>scatterer</em>, <em>optics</em><big>)</big><a class="headerlink" href="#holopy.scattering.theory.multisphere.Multisphere.calc_cross_sections" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate scattering, absorption, and extinction
cross sections, and asymmetry parameter &lt;cos    heta&gt;.
To be implemented by derived classes.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>scatterer</strong> : <a class="reference internal" href="holopy.scattering.scatterer.html#module-holopy.scattering.scatterer" title="holopy.scattering.scatterer"><tt class="xref py py-mod docutils literal"><span class="pre">scatterer</span></tt></a> object</p>
<blockquote>
<div><p>(possibly composite) scatterer for which to compute scattering</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns :</th><td class="field-body"><p class="first"><strong>cross_sections</strong> : array (4)</p>
<blockquote class="last">
<div><p>Dimensional scattering, absorption, and extinction
cross sections, and &lt;cos theta&gt;</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>calc_* functions can be called on either a theory class or a theory
object.  If called on a theory class, they use a default theory object
which is correct for the vast majority of situations.  You only need to
instantiate a theory object if it has adjustable parameters and you want
to use non-default values.</p>
</dd></dl>

<dl class="classmethod">
<dt id="holopy.scattering.theory.multisphere.Multisphere.calc_field">
<em class="property">classmethod </em><tt class="descname">calc_field</tt><big>(</big><em>cls_self</em>, <em>scatterer</em>, <em>schema</em>, <em>scaling=1.0</em><big>)</big><a class="headerlink" href="#holopy.scattering.theory.multisphere.Multisphere.calc_field" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate fields.  Implemented in derived classes only.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>scatterer</strong> : <a class="reference internal" href="holopy.scattering.scatterer.html#module-holopy.scattering.scatterer" title="holopy.scattering.scatterer"><tt class="xref py py-mod docutils literal"><span class="pre">scatterer</span></tt></a> object</p>
<blockquote>
<div><p>(possibly composite) scatterer for which to compute scattering</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns :</th><td class="field-body"><p class="first"><strong>e_field</strong> : <tt class="xref py py-mod docutils literal"><span class="pre">VectorGrid</span></tt></p>
<blockquote class="last">
<div><p>scattered electric field</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>calc_* functions can be called on either a theory class or a theory
object.  If called on a theory class, they use a default theory object
which is correct for the vast majority of situations.  You only need to
instantiate a theory object if it has adjustable parameters and you want
to use non-default values.</p>
</dd></dl>

<dl class="classmethod">
<dt id="holopy.scattering.theory.multisphere.Multisphere.calc_holo">
<em class="property">classmethod </em><tt class="descname">calc_holo</tt><big>(</big><em>cls_self</em>, <em>scatterer</em>, <em>schema</em>, <em>scaling=1.0</em><big>)</big><a class="headerlink" href="#holopy.scattering.theory.multisphere.Multisphere.calc_holo" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate hologram formed by interference between scattered
fields and a reference wave</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>scatterer</strong> : <a class="reference internal" href="holopy.scattering.scatterer.html#module-holopy.scattering.scatterer" title="holopy.scattering.scatterer"><tt class="xref py py-mod docutils literal"><span class="pre">scatterer</span></tt></a> object</p>
<blockquote>
<div><p>(possibly composite) scatterer for which to compute scattering</p>
</div></blockquote>
<p><strong>scaling</strong> : scaling value (alpha) for intensity of reference wave</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns :</th><td class="field-body"><p class="first"><strong>holo</strong> : <a class="reference internal" href="holopy.core.marray.html#holopy.core.marray.Image" title="holopy.core.marray.Image"><tt class="xref py py-class docutils literal"><span class="pre">Image</span></tt></a> object</p>
<blockquote class="last">
<div><p>Calculated hologram from the given distribution of spheres</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>calc_* functions can be called on either a theory class or a theory
object.  If called on a theory class, they use a default theory object
which is correct for the vast majority of situations.  You only need to
instantiate a theory object if it has adjustable parameters and you want
to use non-default values.</p>
</dd></dl>

<dl class="classmethod">
<dt id="holopy.scattering.theory.multisphere.Multisphere.calc_intensity">
<em class="property">classmethod </em><tt class="descname">calc_intensity</tt><big>(</big><em>cls_self</em>, <em>scatterer</em>, <em>schema</em>, <em>scaling=1.0</em><big>)</big><a class="headerlink" href="#holopy.scattering.theory.multisphere.Multisphere.calc_intensity" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate intensity at focal plane (z=0)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>scatterer</strong> : <a class="reference internal" href="holopy.scattering.scatterer.html#module-holopy.scattering.scatterer" title="holopy.scattering.scatterer"><tt class="xref py py-mod docutils literal"><span class="pre">scatterer</span></tt></a> object</p>
<blockquote>
<div><p>(possibly composite) scatterer for which to compute scattering</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns :</th><td class="field-body"><p class="first"><strong>inten</strong> : <tt class="xref py py-mod docutils literal"><span class="pre">Image</span></tt></p>
<blockquote class="last">
<div><p>scattered intensity</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>calc_* functions can be called on either a theory class or a theory
object.  If called on a theory class, they use a default theory object
which is correct for the vast majority of situations.  You only need to
instantiate a theory object if it has adjustable parameters and you want
to use non-default values.</p>
<p>Total scattered intensity only takes into account the x- and
y-components of the E-field.  The z-component is ignored
because the detector&#8217;s pixels should be sensitive to the z
component of the Poynting vector, E x B, and the z component
of E x B cannot depend on Ez.</p>
</dd></dl>

<dl class="classmethod">
<dt id="holopy.scattering.theory.multisphere.Multisphere.calc_scat_matrix">
<em class="property">classmethod </em><tt class="descname">calc_scat_matrix</tt><big>(</big><em>cls_self</em>, <em>scatterer</em>, <em>schema</em><big>)</big><a class="headerlink" href="#holopy.scattering.theory.multisphere.Multisphere.calc_scat_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute scattering matricies for scatterer</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>scatterer</strong> : <a class="reference internal" href="holopy.scattering.scatterer.html#module-holopy.scattering.scatterer" title="holopy.scattering.scatterer"><tt class="xref py py-mod docutils literal"><span class="pre">holopy.scattering.scatterer</span></tt></a> object</p>
<blockquote>
<div><p>(possibly composite) scatterer for which to compute scattering</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns :</th><td class="field-body"><p class="first"><strong>scat_matr</strong> : <tt class="xref py py-mod docutils literal"><span class="pre">Marray</span></tt></p>
<blockquote class="last">
<div><p>Scattering matricies at specified positions</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>calc_* functions can be called on either a theory class or a theory
object.  If called on a theory class, they use a default theory object
which is correct for the vast majority of situations.  You only need to
instantiate a theory object if it has adjustable parameters and you want
to use non-default values.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-holopy.scattering.theory.dda">
<span id="dda-module"></span><h2><tt class="xref py py-mod docutils literal"><span class="pre">dda</span></tt> Module<a class="headerlink" href="#module-holopy.scattering.theory.dda" title="Permalink to this headline">¶</a></h2>
<p>Compute holograms using the discrete dipole approximation (DDA).  Currently uses
ADDA (<a class="reference external" href="http://code.google.com/p/a-dda/">http://code.google.com/p/a-dda/</a>) to do DDA calculations.</p>
<dl class="class">
<dt id="holopy.scattering.theory.dda.DDA">
<em class="property">class </em><tt class="descclassname">holopy.scattering.theory.dda.</tt><tt class="descname">DDA</tt><big>(</big><em>n_cpu=1</em>, <em>max_dpl_size=None</em><big>)</big><a class="headerlink" href="#holopy.scattering.theory.dda.DDA" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#holopy.scattering.theory.scatteringtheory.ScatteringTheory" title="holopy.scattering.theory.scatteringtheory.ScatteringTheory"><tt class="xref py py-class docutils literal"><span class="pre">holopy.scattering.theory.scatteringtheory.ScatteringTheory</span></tt></a></p>
<p>Computes scattering using the the Discrete Dipole Approximation (DDA).</p>
<p>It can (in principle) calculate scattering from any arbitrary scatterer.
The DDA uses a numerical method that represents arbitrary scatterers as
an array
of point dipoles and then self-consistently solves Maxwell&#8217;s equations
to determine the scattered field. In practice, this model can be
extremely computationally intensive, particularly if the size of the
scatterer is larger than the wavelength of light.  This model requires an
external scattering code: <a class="reference external" href="http://code.google.com/p/a-dda/">a-dda</a></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Attributes :</th><td class="field-body"><p class="first"><strong>n_cpu</strong> : int (optional)</p>
<blockquote>
<div><p>Number of threads to use for the DDA calculation</p>
</div></blockquote>
<p><strong>max_dpl_size</strong> : float (optional)</p>
<blockquote>
<div><p>Force a maximum dipole size. This is useful for forcing extra dipoles if
necessary to resolve features in an object. This may make dda
calculations take much longer.</p>
</div></blockquote>
<p><strong>Notes</strong> :</p>
<p><strong>&#8212;&#8211;</strong> :</p>
<p><strong>Does not handle near fields.  This introduces ~5% error at 10 microns.</strong> :</p>
<p><strong>This can in principle handle any scatterer, but in practice it will need</strong> :</p>
<p class="last"><strong>excessive memory or computation time for particularly large scatterers.</strong> :</p>
</td>
</tr>
</tbody>
</table>
<dl class="classmethod">
<dt id="holopy.scattering.theory.dda.DDA.calc_cross_sections">
<em class="property">classmethod </em><tt class="descname">calc_cross_sections</tt><big>(</big><em>cls_self</em>, <em>scatterer</em>, <em>optics</em><big>)</big><a class="headerlink" href="#holopy.scattering.theory.dda.DDA.calc_cross_sections" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate scattering, absorption, and extinction
cross sections, and asymmetry parameter &lt;cos    heta&gt;.
To be implemented by derived classes.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>scatterer</strong> : <a class="reference internal" href="holopy.scattering.scatterer.html#module-holopy.scattering.scatterer" title="holopy.scattering.scatterer"><tt class="xref py py-mod docutils literal"><span class="pre">scatterer</span></tt></a> object</p>
<blockquote>
<div><p>(possibly composite) scatterer for which to compute scattering</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns :</th><td class="field-body"><p class="first"><strong>cross_sections</strong> : array (4)</p>
<blockquote class="last">
<div><p>Dimensional scattering, absorption, and extinction
cross sections, and &lt;cos theta&gt;</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>calc_* functions can be called on either a theory class or a theory
object.  If called on a theory class, they use a default theory object
which is correct for the vast majority of situations.  You only need to
instantiate a theory object if it has adjustable parameters and you want
to use non-default values.</p>
</dd></dl>

<dl class="classmethod">
<dt id="holopy.scattering.theory.dda.DDA.calc_field">
<em class="property">classmethod </em><tt class="descname">calc_field</tt><big>(</big><em>cls_self</em>, <em>scatterer</em>, <em>schema</em>, <em>scaling=1.0</em><big>)</big><a class="headerlink" href="#holopy.scattering.theory.dda.DDA.calc_field" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate fields.  Implemented in derived classes only.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>scatterer</strong> : <a class="reference internal" href="holopy.scattering.scatterer.html#module-holopy.scattering.scatterer" title="holopy.scattering.scatterer"><tt class="xref py py-mod docutils literal"><span class="pre">scatterer</span></tt></a> object</p>
<blockquote>
<div><p>(possibly composite) scatterer for which to compute scattering</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns :</th><td class="field-body"><p class="first"><strong>e_field</strong> : <tt class="xref py py-mod docutils literal"><span class="pre">VectorGrid</span></tt></p>
<blockquote class="last">
<div><p>scattered electric field</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>calc_* functions can be called on either a theory class or a theory
object.  If called on a theory class, they use a default theory object
which is correct for the vast majority of situations.  You only need to
instantiate a theory object if it has adjustable parameters and you want
to use non-default values.</p>
</dd></dl>

<dl class="classmethod">
<dt id="holopy.scattering.theory.dda.DDA.calc_holo">
<em class="property">classmethod </em><tt class="descname">calc_holo</tt><big>(</big><em>cls_self</em>, <em>scatterer</em>, <em>schema</em>, <em>scaling=1.0</em><big>)</big><a class="headerlink" href="#holopy.scattering.theory.dda.DDA.calc_holo" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate hologram formed by interference between scattered
fields and a reference wave</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>scatterer</strong> : <a class="reference internal" href="holopy.scattering.scatterer.html#module-holopy.scattering.scatterer" title="holopy.scattering.scatterer"><tt class="xref py py-mod docutils literal"><span class="pre">scatterer</span></tt></a> object</p>
<blockquote>
<div><p>(possibly composite) scatterer for which to compute scattering</p>
</div></blockquote>
<p><strong>scaling</strong> : scaling value (alpha) for intensity of reference wave</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns :</th><td class="field-body"><p class="first"><strong>holo</strong> : <a class="reference internal" href="holopy.core.marray.html#holopy.core.marray.Image" title="holopy.core.marray.Image"><tt class="xref py py-class docutils literal"><span class="pre">Image</span></tt></a> object</p>
<blockquote class="last">
<div><p>Calculated hologram from the given distribution of spheres</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>calc_* functions can be called on either a theory class or a theory
object.  If called on a theory class, they use a default theory object
which is correct for the vast majority of situations.  You only need to
instantiate a theory object if it has adjustable parameters and you want
to use non-default values.</p>
</dd></dl>

<dl class="classmethod">
<dt id="holopy.scattering.theory.dda.DDA.calc_intensity">
<em class="property">classmethod </em><tt class="descname">calc_intensity</tt><big>(</big><em>cls_self</em>, <em>scatterer</em>, <em>schema</em>, <em>scaling=1.0</em><big>)</big><a class="headerlink" href="#holopy.scattering.theory.dda.DDA.calc_intensity" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate intensity at focal plane (z=0)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>scatterer</strong> : <a class="reference internal" href="holopy.scattering.scatterer.html#module-holopy.scattering.scatterer" title="holopy.scattering.scatterer"><tt class="xref py py-mod docutils literal"><span class="pre">scatterer</span></tt></a> object</p>
<blockquote>
<div><p>(possibly composite) scatterer for which to compute scattering</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns :</th><td class="field-body"><p class="first"><strong>inten</strong> : <tt class="xref py py-mod docutils literal"><span class="pre">Image</span></tt></p>
<blockquote class="last">
<div><p>scattered intensity</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>calc_* functions can be called on either a theory class or a theory
object.  If called on a theory class, they use a default theory object
which is correct for the vast majority of situations.  You only need to
instantiate a theory object if it has adjustable parameters and you want
to use non-default values.</p>
<p>Total scattered intensity only takes into account the x- and
y-components of the E-field.  The z-component is ignored
because the detector&#8217;s pixels should be sensitive to the z
component of the Poynting vector, E x B, and the z component
of E x B cannot depend on Ez.</p>
</dd></dl>

<dl class="classmethod">
<dt id="holopy.scattering.theory.dda.DDA.calc_scat_matrix">
<em class="property">classmethod </em><tt class="descname">calc_scat_matrix</tt><big>(</big><em>cls_self</em>, <em>scatterer</em>, <em>schema</em><big>)</big><a class="headerlink" href="#holopy.scattering.theory.dda.DDA.calc_scat_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute scattering matricies for scatterer</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>scatterer</strong> : <a class="reference internal" href="holopy.scattering.scatterer.html#module-holopy.scattering.scatterer" title="holopy.scattering.scatterer"><tt class="xref py py-mod docutils literal"><span class="pre">holopy.scattering.scatterer</span></tt></a> object</p>
<blockquote>
<div><p>(possibly composite) scatterer for which to compute scattering</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns :</th><td class="field-body"><p class="first"><strong>scat_matr</strong> : <tt class="xref py py-mod docutils literal"><span class="pre">Marray</span></tt></p>
<blockquote class="last">
<div><p>Scattering matricies at specified positions</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>calc_* functions can be called on either a theory class or a theory
object.  If called on a theory class, they use a default theory object
which is correct for the vast majority of situations.  You only need to
instantiate a theory object if it has adjustable parameters and you want
to use non-default values.</p>
</dd></dl>

</dd></dl>

</div>
</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="holopy.fitting.html" title="fitting Package"
             >next</a> |</li>
        <li class="right" >
          <a href="holopy.scattering.scatterer.html" title="scatterer Package"
             >previous</a> |</li>
        <li><a href="../index.html">home</a>|&nbsp;</li>
        <li><a href="../search.html">search</a>|&nbsp;</li>

          <li><a href="holopy.html" ><tt class="docutils literal"><span class="pre">holopy</span></tt> Code Reference</a> &raquo;</li>
          <li><a href="holopy.scattering.html" >scattering Package</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2011-2013, Manoharan Lab, Harvard University.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
    </div>
  </body>
</html>